/******************************************************************************/
/*
  Project   - MudBun
  Publisher - Long Bunny Labs
              http://LongBunnyLabs.com
  Author    - Ming-Lun "Allen" Chou
              http://AllenChou.net
*/
/******************************************************************************/

#pragma kernel clear_voxel_hash_table
#pragma kernel clear_voxel_cache
#pragma kernel register_top_nodes
#pragma kernel update_branching_indirect_dispatch_args
#pragma kernel allocate_child_nodes
#pragma kernel update_voxel_indirect_dispatch_args
#pragma kernel generate_mesh_flat
#pragma kernel generate_mesh_smooth
#pragma kernel generate_splats

#define kThreadGroupExtent (4)
#define kThreadGroupSize (kThreadGroupExtent * kThreadGroupExtent * kThreadGroupExtent)
#define kClearThreadGroupSize (256)

#define MUDBUN_IS_COMPUTE_SHADER (1)

#include "../../Shader/AabbTreeFuncs.cginc"
#include "../../Shader/BrushFuncs.cginc"
#include "../../Shader/GenPointDefs.cginc"
#include "../../Shader/MarchingCubes.cginc"
#include "../../Shader/Math/MathConst.cginc"
#include "../../Shader/VoxelFuncs.cginc"
#include "../../Shader/VoxelCacheFuncs.cginc"
#include "../../Shader/VoxelHashFuncs.cginc"

RWStructuredBuffer<int> indirectDispatchArgs;
RWStructuredBuffer<int> indirectDrawArgs;

[numthreads(kClearThreadGroupSize, 1, 1)]
void clear_voxel_hash_table(int id : SV_DispatchThreadID)
{
  if (id.x >= nodeHashTableSize)
    return;

  nodeHashTable[id.x].id = kNullVoxelHashId;
}

[numthreads(kClearThreadGroupSize, 1, 1)]
void clear_voxel_cache(int id : SV_DispatchThreadID)
{
  if (id.x >= int(voxelCacheSize))
    return;

  voxelCacheIdTable[id.x] = kNullVoxelCacheId;
  voxelCache[id.x].data = kFltMax;
}

[numthreads(kThreadGroupSize, 1, 1)]
void register_top_nodes(int3 id : SV_DispatchThreadID)
{
  int iBrush = id.x;
  if (iBrush >= numBrushes)
    return;

  register_brush_aabb(iBrush);
}

[numthreads(1, 1, 1)]
void update_branching_indirect_dispatch_args(int3 id : SV_DispatchThreadID)
{
  indirectDispatchArgs[0] = 
    max
    (
      1, 
      uint
      (
        min
        (
          nodePoolSize, 
          aNumNodesAllocated[currentNodeDepth + 1]
        ) 
        * (currentNodeBranchingFactor * currentNodeBranchingFactor * currentNodeBranchingFactor) 
        + kThreadGroupSize - 1
      ) / kThreadGroupSize
    );
}

[numthreads(kThreadGroupSize, 1, 1)]
void allocate_child_nodes(uint3 id : SV_DispatchThreadID)
{
  uint f = currentNodeBranchingFactor;
  uint ff = f * f;
  uint fff = ff * f;
  uint iNode = uint(id.x) / fff;
  if (iNode >= uint(aNumNodesAllocated[currentNodeDepth + 1]))
    return;

  for (int i = 1; i <= currentNodeDepth; ++i)
    iNode += aNumNodesAllocated[i];
  if (iNode >= nodePoolSize)
    return;

  uint3 qChildNode = (id.x / uint3(1, f, ff)) % f;
  float childSize = currentNodeSize / currentNodeBranchingFactor;
  float3 childCenter = nodePool[iNode].center - ((f / 2) - 0.5f - qChildNode) * childSize;
  float childDiag = 1.733f * childSize;

  float d = sdf_masked_brushes(childCenter, get_brush_mask_index(iNode));
  if (d > 0.5f * childDiag || d < -childDiag)
  {
    // could deviation from distortion or modifier possibly bring solid surface close to voxel?
    bool deviationClose = false;

    FOR_EACH_BRUSH(get_brush_mask_index(iNode), 
      switch (aBrush[iBrush].op)
      {
        case kSdfDistort:
        case kSdfModify:
        {
          float deviation = aBrush[iBrush].blend;
          float res = sdf_distortion_modifier_bounds_query(childCenter, aBrush[iBrush]);
          if (res <= childDiag 
              && abs(d) - deviation <= childDiag)
          {
            deviationClose = true;
          }

          break;
        }
      }
      if (deviationClose)
        break;
    );

    if (!deviationClose)
      return;
  }

  int iChildNode = allocate_node(childCenter, currentNodeDepth + 1, iNode);
  if (iChildNode < 0)
    return;

  float halfChildSize = 0.5f * childSize;
  Aabb childAabb = make_aabb(childCenter - halfChildSize, childCenter + halfChildSize);
  nodePool[iChildNode].iBrushMask = allocate_node_brush_mask(iChildNode, childAabb);
}

[numthreads(1, 1, 1)]
void update_voxel_indirect_dispatch_args(int3 id : SV_DispatchThreadID)
{
  indirectDispatchArgs[0] = aNumNodesAllocated[currentNodeDepth + 1];
    max
    (
      1, 
      uint
      (
        min
        (
          nodePoolSize, 
          aNumNodesAllocated[currentNodeDepth + 1]
        ) 
        + kThreadGroupSize - 1
      ) / kThreadGroupSize
    );
}

[numthreads(kThreadGroupSize, 1, 1)]
void generate_mesh_flat(int3 id : SV_DispatchThreadID)
{
  uint iNode = uint(id.x);
  if (iNode >= uint(aNumNodesAllocated[currentNodeDepth + 1]))
    return;

  for (int i = 1; i <= currentNodeDepth; ++i)
    iNode += aNumNodesAllocated[i];
  iNode = min(iNode, nodePoolSize - 1);
  if (iNode >= nodePoolSize)
    return;

  int iBrushMask = get_brush_mask_index(iNode);
  SdfBrushMaterial cubeMat;
  MARCHING_CUBES(nodePool[iNode].center, currentNodeSize, sdf_masked_brushes, sdf_masked_brushes_normal, iBrushMask, false, cubeMat, 
    // tStmtPre
    int iVertBase = 0;
    InterlockedAdd(indirectDrawArgs[0], 3, iVertBase);
    , 
    // vStmt
    aGenPoint[iVertBase + iVert].posNorm = float4(aVertPos[iVert], pack_normal(aVertNorm[iVert]));
    aGenPoint[iVertBase + iVert].material = pack_material(cubeMat);
    , 
    // tStmtPost
    { }
  );
}

[numthreads(kThreadGroupSize, 1, 1)]
void generate_mesh_smooth(int3 id : SV_DispatchThreadID)
{
  uint iNode = uint(id.x);
  if (iNode >= uint(aNumNodesAllocated[currentNodeDepth + 1]))
    return;

  for (int i = 1; i <= currentNodeDepth; ++i)
    iNode += aNumNodesAllocated[i];
  iNode = min(iNode, nodePoolSize - 1);
  if (iNode >= nodePoolSize)
    return;

  int iBrushMask = get_brush_mask_index(iNode);
  SdfBrushMaterial cubeMat;
  MARCHING_CUBES(nodePool[iNode].center, currentNodeSize, sdf_masked_brushes, sdf_masked_brushes_normal, iBrushMask, true, cubeMat, 
    // tStmtPre
    int iVertBase = 0;
    InterlockedAdd(indirectDrawArgs[0], 3, iVertBase);
    , 
    // vStmt
    aGenPoint[iVertBase + iVert].posNorm = float4(aVertPos[iVert], pack_normal(aVertNorm[iVert]));
    aGenPoint[iVertBase + iVert].material = pack_material(aVertMat[iVert]);
    , 
    // tStmtPost
    { }
  );
}

[numthreads(kThreadGroupSize, 1, 1)]
void generate_splats(int3 id : SV_DispatchThreadID)
{
  uint iNode = uint(id.x);
  if (iNode >= uint(aNumNodesAllocated[currentNodeDepth + 1]))
    return;

  for (int i = 1; i <= currentNodeDepth; ++i)
    iNode += aNumNodesAllocated[i];
  iNode = min(iNode, nodePoolSize - 1);
  if (iNode >= nodePoolSize)
    return;

  int numTris = 0;
  float3 avgPos = 0.0f;
  float3 avgNorm = 0.0f;
  float avgWeight = 0.0f;
  int iBrushMask = get_brush_mask_index(iNode);
  SdfBrushMaterial cubeMat;
  MARCHING_CUBES(nodePool[iNode].center, currentNodeSize, sdf_masked_brushes, sdf_masked_brushes_normal, iBrushMask, false, cubeMat, 
    // tStmtPre
    { }
    ,
    // vStmt
    { }
    ,
    // tStmtPost
    float3 c = cross(aVertPos[1] - aVertPos[0], aVertPos[2] - aVertPos[0]);
    float w = length(c);
    avgPos += w * (aVertPos[0] + aVertPos[1] + aVertPos[2]);
    if (w > kEpsilon)
      avgNorm += w * normalize(c);
    avgWeight += w;
    ++numTris;
  );

  if (numTris > 0)
  {
    avgPos /= avgWeight * 3.0f;
    avgNorm = normalize(avgNorm);

    int iVertBase;
    InterlockedAdd(indirectDrawArgs[0], 3, iVertBase);

    float scaleMult = pow(saturate(avgWeight / (0.2f * voxelSize * voxelSize)), 0.1f);
    cubeMat.metallicSmoothnessSizeTightness.z *= scaleMult;

    int iGenPoint = uint(iVertBase) / 3;
    aGenPoint[iGenPoint].posNorm = float4(avgPos, pack_normal(avgNorm));
    aGenPoint[iGenPoint].material = pack_material(cubeMat);
  }
}

